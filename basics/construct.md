---
order: 80
---

# Алгоритмические конструкции
Итак, в прошлой теме мы рассмотрели каким образом можно составлять алгоритмы для наших программ: *словесно*, *алгоритмическим языком* и *блок-схемами*. А какие алгоритмы бывают в принципе? Для того чтобы учитывать все случаи в алгоритмах у нас предусматривается три базовые конструкции: **следования**, **ветвления** и **повторения**.

## Линейные алгоритмы (следования)
Буквально означают и описываются таким образом, что все этапы работы программы выполняются строго последовательно и друг за другом. Пример словесного описания такого алгоритма приводился в прошлой статье задачкой про Васю и Мишу.

```
S1: Начало программы; 
S2: Создаём переменную vasya; 
S3: Создаём переменную misha; 
S4: Присваиваем переменной vasya значение 5; 
S5: Присваиваем переменной misha значение 6; 
S6: Создаём переменную sum; 
S7: Записываем в переменную sum сумму значений из vasya и misha 
S8: Выводим значение sum; 
S9: Завершение программы.
```

В формате блок-схемы данный алгоритм будет выглядеть следующим образом:

```mermaid
graph TB
    AG("&nbsp;Начало&nbsp;")
    style AG rx:25,ry:50 
    AG --> B["var vasya, misha;"]
    B --> C["vasya = 5;<br>misha = 6;"]
    C --> D["var sum = vasya + misha;"]
    D --> E[/Вывод sum/]
    E --> ND
    ND("&nbsp;&nbsp;Конец&nbsp;&nbsp;")
    style ND rx:25,ry:50
 ```
 !!!
 Обратите внимание, что для создания новых переменных мы используем сокращение **var** (от англ. *variable*). Если вы работаете со строго типизированными языками программирования вместо var желательно указывать тип переменной (int, float и т.д.).
 !!!

Давайте разберём каждый блок поочерёдно:
1. Начинаем работу программы
2. Создаём переменные vasya и misha
3. Задаём значения переменным vasya и misha
4. Создаём переменную sum и задаём ей значение суммы vasya и misha
5. Выводим значение sum в консоль
6. Заканчиваем работу программы

Давайте разберём блоки, которые тут присутствуют и что они делают.

 - Прямоугольник - **действие** (*или операция*). Этот блок мы используем в тех случаях, когда вводим в систему новые переменные или осуществляем базовые операции: изменение значения, математические операции и т.д.
 - Параллелограмм - **данные** (*или ввод-вывод*). С помощью этого блока мы выводим значения переменных или произвольный текст в консоль, а также считываем значения вводом с клавиатуры; так пользователь может указывать значения переменных по ходу работы программы.
 - Почти овал (закругленный прямоугольник) - **ограничитель**. Этот блок указывает, где у нас начинается программа и где она заканчивается.
 
 
 ## Условные алгоритмы (ветвления)
 
Пускай линейные алгоритмы и являются самыми распространёнными и необходимыми, но они довольно ограничены в своих возможностях. Когда мы рассматриваем однозначные, базисные задачки, они превосходно справляются со своей целью. Но что если мы возьмём задачу поинтереснее?

> Пользователь вводит с клавиатуры число А. Напишите программу которая определяет, было введено положительное или отрицательное число.

В случае с такой задачкой нам необходимо каким-то образом проверить введённое число и вывести сообщение о том, положительное оно или отрицательное. И тут нам на помощь приходят алгоритмы ветвления!

С помощью данных алгоритмов мы можем проверять переменные на то, чтобы они удовлетворяли определённому условию. Если **условие выполняется**, то у нас происходят одни операции, а если **нет** - то другие. Описывается это всё дело следующим образом:
```
S1. Начало работы программы;
S2. Создаём переменную А;
S3. Вводим значение переменной А с клавиатуры;
S4. Если переменная А < 0, то переходим к S5, иначе S6;
S5. Выводим сообщение "А - отрицательное" и идём к S7;
S6. Выводим сообщение "А - положительное" и идём к S7;
S7. Завершение работы программы.
```
На блок-схеме такие алгоритмы понять можно проще:

```mermaid
	%%{ init: { 'flowchart': { 'curve': 'stepAfter' } } }%%
	graph TB
	A(Начало) --> B["var A;"]
	style A rx:25,ry:50
	B --> C[/Ввод А/]
	C --> D{A < 0?}
	D -->|Да| E[/Вывод ''А - отрицательное''/]
	D -->|Нет| F[/Вывод ''А - положительное''/]
	E --> G(Конец)
	F --> G
	style G rx:25,ry:50
```

Но вот ведь незадача: если мы введём ноль, то программа нам ничего не выдаст. Чтобы решить такую проблему мы можем вложить одно условие в другое.

```mermaid
	%%{ init: { 'flowchart': { 'curve': 'stepAfter' } } }%%
	graph TB
	A(Начало) --> B["var A;"]
	style A rx:25,ry:50
	B --> C[/Ввод А/]
	C --> D{A < 0?}
	D -->|Да| E[/Вывод ''А - отрицательное''/]
	D -->|Нет| F{A > 0?}
	F -->|Да| F1[/Вывод ''А - положительное''/]
	F -->|Нет| F2[/Вывод ''А равно нулю''/]
	E --> G(Конец)
	F1 --> G
	F2 --> G
	style G rx:25,ry:50
```
В первом условии мы также рассматриваем, *меньше нуля ли у нас А*. Если нет, то у нас остаётся два варианта: либо **А > 0**, либо **A равно нулю**. Поэтому мы на ветке "**нет**" создаём ещё одно условие, где и проверяем, больше нуля ли у нас А.

Если **да**, то выводим соответствующее сообщение.  
Если **нет**, то последним случаем, который мы не рассмотрели остаётся **А = 0** и мы также выводим сообщение.

## Циклические алгоритмы (повторения)
